<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="author" content="Sunghyun Park">
    <meta name="description" content="Blog posts by Sunghyun Park">
    <title>Sunghyun Park â€“ Blog</title>
    <!-- Favicon -->
    <link rel="shortcut icon" type="image/x-icon" href="static/img/jlcrimson.png">
    <!-- CSS dependencies -->
    <link href="static/plugin/bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <link href="static/plugin/academicons/css/academicons.min.css" rel="stylesheet">
    <link href="static/plugin/et-line/style.css" rel="stylesheet">
    <link href="static/plugin/themify-icons/themify-icons.css" rel="stylesheet">
    <link href="static/plugin/owl-carousel/css/owl.carousel.min.css" rel="stylesheet">
    <link href="static/plugin/magnific/magnific-popup.css" rel="stylesheet">
    <link href="static/plugin/scroll/jquery.mCustomScrollbar.min.css" rel="stylesheet">
    <!-- Theme CSS -->
    <link href="static/css/style.css" rel="stylesheet">
    <!-- Markdown parser -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

    <!-- Font Awesome Kit for icons -->
    <script src="https://kit.fontawesome.com/912387ca83.js" crossorigin="anonymous"></script>

    <!-- MathJax for rendering LaTeX expressions. Configuration must come before loading. -->
    <script>
        // Configure inline math delimiters and ignore tags that should not be processed.
        window.MathJax = {
            tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] },
            options: { skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'] }
        };
    </script>
    <!-- Load MathJax asynchronously to avoid blocking page rendering -->
    <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body data-spy="scroll" data-target="#navbar-collapse-toggle" data-offset="70" class="theme-light">
    <!-- Page Loading -->
    <div id="loading">
        <div class="load-circle"><span class="one"></span></div>
    </div>
    <!-- Mobile header -->
    <div class="mob-header">
        <div class="d-flex">
            <div class="navbar-brand">
                <a class="logo-text" href="index.html">
                    Sunghyun Park
                </a>
            </div>
            <button class="toggler-menu">
                <span></span>
                <span></span>
                <span></span>
            </button>
        </div>
    </div>
    <!-- Sidebar navigation -->
    <header class="header-left" id="navbar-collapse-toggle">
        <div class="scroll-bar">
            <div class="hl-top">
                <div class="hl-logo">
                    <a href="#">SP</a>
                </div>
            </div>
            <ul class="nav nav-menu">
                <li>
                    <a class="nav-link" href="index.html#about" data-toggle="tooltip" title="Home">
                        <i class="fas fa-home"></i>
                    </a>
                </li>
                <li>
                    <a class="nav-link" href="index.html#education" data-toggle="tooltip" title="Education">
                        <i class="fas fa-graduation-cap"></i>
                    </a>
                </li>
                <li>
                    <a class="nav-link" href="index.html#publications" data-toggle="tooltip" title="Projects">
                        <i class="fas fa-file-alt"></i>
                    </a>
                </li>
                <li>
                    <a class="nav-link" href="index.html#experience" data-toggle="tooltip" title="Experience">
                        <i class="fas fa-briefcase"></i>
                    </a>
                </li>
                <li>
                    <a class="nav-link" href="index.html#awards" data-toggle="tooltip" title="Awards & Honors">
                        <i class="fas fa-trophy"></i>
                    </a>
                </li>
                <li>
                    <a class="nav-link" href="gallery.html" data-toggle="tooltip" title="Gallery">
                        <i class="fas fa-images"></i>
                    </a>
                </li>
                <li>
                    <a class="nav-link active" href="blog.html" data-toggle="tooltip" title="Blog">
                        <i class="fas fa-blog"></i>
                    </a>
                </li>
            </ul>
        </div>
    </header>
    <!-- Main content -->
    <main class="main-left">
        <section id="blog" class="section">
            <div class="container">
                <div class="title">
                    <h3>Blog.</h3>
                    <p>All posts in this blog are stored as Markdown (<code>.md</code>) files in the <code>blogs</code> folder of your GitHub repository.  Posts can be organised into folders to create nested categories, and each post may contain images or equations.  Use the category tree and search box to find posts and click a card to read the full article.</p>
                </div>
                <!-- Blog layout: sidebar for categories and main area for feed -->
                <div class="row">
                    <!-- Sidebar: collapsible category tree -->
                    <aside class="col-12 col-md-4 col-lg-3 mb-4" id="blog-sidebar">
                        <h5 class="mb-3">Browse by category</h5>
                        <nav id="category-tree" class="cat-tree"></nav>
                    </aside>
                    <!-- Main content: search + feed + post -->
                    <div class="col-12 col-md-8 col-lg-9" id="blog-main">
                        <!-- Search bar -->
                        <div class="form-group">
                            <input type="search" id="blog-search" class="form-control" placeholder="Search posts...">
                        </div>
                        <!-- Feed: cards of posts -->
                        <div id="blog-feed" class="row"></div>
                        <!-- Single post view: hidden by default -->
                        <div id="blog-post" style="display: none;">
                            <div class="post-controls mb-3">
                                <button id="back-to-list" class="btn btn-sm btn-secondary mr-2">Back to Blog</button>
                                <a href="index.html#about" class="btn btn-sm btn-primary">Back to Introduction</a>
                            </div>
                            <div id="blog-post-content"></div>
                        </div>
                    </div>
                </div>
            </div>
        </section>
    </main>
    <!-- JavaScript dependencies -->
    <script src="static/js/jquery-3.2.1.min.js"></script>
    <script src="static/js/jquery-migrate-3.0.0.min.js"></script>
    <script src="static/plugin/bootstrap/js/bootstrap.min.js"></script>
    <script src="static/plugin/scroll/jquery.mCustomScrollbar.concat.min.js"></script>
    <script src="static/plugin/owl-carousel/js/owl.carousel.min.js"></script>
    <script src="static/plugin/particles/particles.min.js"></script>
    <script src="static/plugin/magnific/jquery.magnific-popup.min.js"></script>
    <script src="static/js/custom.js"></script>
    <!-- Blog script: fetch markdown files from GitHub, build a categorized list, and show individual posts -->
    <script>
        /**
         * Customize the Markdown renderer to support relative images from the repository.
         *
         * When a post includes an image with a relative path (e.g. `static/img/myphoto.jpg`), this function
         * converts that path into a raw GitHub URL.  This ensures images stored in your repository are displayed
         * correctly when the blog is hosted via GitHub Pages.  The rendered `<img>` tags also use the
         * `img-fluid` and `my-3` Bootstrap classes for responsive sizing and spacing.
         */
        (function() {
            const renderer = new marked.Renderer();
            renderer.image = function (href, title, text) {
                let src = href;
                // For local or relative paths (no protocol and not a data URI), build a GitHub raw URL
                if (href && !href.match(/^https?:\/\//) && !href.startsWith('data:')) {
                    const cleanHref = href.replace(/^\/+/, '');
                    src = `https://raw.githubusercontent.com/${githubUsername}/${githubRepo}/${branch}/${cleanHref}`;
                }
                const titleAttr = title ? ` title="${title}"` : '';
                return `<img src="${src}" alt="${text}"${titleAttr} class="img-fluid my-3">`;
            };
            marked.setOptions({ renderer });
        })();
        // Replace these variables with your GitHub username and repository name
        const githubUsername = 'SunghyunP-ark';
        const githubRepo = 'sunghyunp-ark.github.io';
        const branch = 'main';
        const blogDir = 'blogs';

        // Utility: parse front matter (YAML) from a markdown string
        function parseFrontMatter(md) {
            // Normalize CRLF to LF to support different line endings from GitHub
            // Normalize CRLF to LF to support different line endings from GitHub
            md = md.replace(/\r\n/g, '\n');
            // Front matter starts with '---' on its own line and ends with another '---' line.
            // Allow optional whitespace after the dashes for robustness.
            const fmMatch = md.match(/^---\s*\n([\s\S]*?)\n---\s*\n/);
            let front = {};
            let content = md;
            if (fmMatch) {
                const frontRaw = fmMatch[1];
                frontRaw.split(/\n/).forEach(line => {
                    const idx = line.indexOf(':');
                    if (idx !== -1) {
                        const key = line.slice(0, idx).trim();
                        let val = line.slice(idx + 1).trim();
                        // remove wrapping quotes if any
                        if ((val.startsWith('"') && val.endsWith('"')) || (val.startsWith("'") && val.endsWith("'"))) {
                            val = val.slice(1, -1);
                        }
                        front[key] = val;
                    }
                });
                content = md.slice(fmMatch[0].length);
            }
            return { front, content };
        }

        /* ========================================================================
         * Blog script: recursively load posts from GitHub, build a collapsible category tree,
         * provide search and filtering, and display posts as cards.  Posts are fetched from
         * the `blogs` directory of your repository.  Each post's file path determines its
         * category hierarchy (e.g. `blogs/topic1/page1.md` -> category "topic1").  Front
         * matter may override the title or date fields.  MathJax is used to typeset
         * inline/block LaTeX expressions, and the marked renderer above customises images.
         * =======================================================================*/
        const posts = [];
        const categoryTree = { name: 'All', path: [], children: {}, posts: [] };
        let currentCategoryPath = []; // an array of path segments representing the selected category
        let searchQuery = '';

        /**
         * Recursively fetch markdown files from the GitHub API.  Populates the `posts`
         * array and the `categoryTree` based on file paths.
         * @param {string} dir Relative path inside the blogs directory ('' for root)
         * @param {string[]} parentPath The accumulated path segments for categories
         */
        async function fetchPostsFromDir(dir = '', parentPath = []) {
            const basePath = blogDir + (dir ? '/' + dir : '');
            const url = `https://api.github.com/repos/${githubUsername}/${githubRepo}/contents/${basePath}?ref=${branch}`;
            let files;
            try {
                const resp = await fetch(url);
                files = await resp.json();
            } catch (err) {
                console.error('Error listing directory', basePath, err);
                return;
            }
            // Sort directories first then files for deterministic ordering
            files.sort((a, b) => {
                if (a.type === b.type) {
                    return a.name.localeCompare(b.name);
                }
                return a.type === 'dir' ? -1 : 1;
            });
            for (const item of files) {
                if (item.type === 'dir') {
                    // Recurse into subdirectories, updating the path segments
                    const newPath = [...parentPath, item.name];
                    await fetchPostsFromDir(dir ? `${dir}/${item.name}` : item.name, newPath);
                } else if (item.type === 'file' && item.name.endsWith('.md')) {
                    try {
                        const res = await fetch(item.download_url);
                        const mdContent = await res.text();
                        const { front, content } = parseFrontMatter(mdContent);
                        const title = front.title || item.name.replace(/\.md$/, '');
                        const date = front.date || '';
                        // Convert markdown to HTML
                        const html = marked.parse(content);
                        // Compute plain text excerpt (first 40 words)
                        let excerpt = '';
                        {
                            const tmp = document.createElement('div');
                            tmp.innerHTML = html;
                            const text = tmp.textContent || tmp.innerText || '';
                            const words = text.trim().split(/\s+/).slice(0, 40);
                            excerpt = words.join(' ');
                        }
                        // Build category paths from front matter (category/categories) or folder path.
                        let categoryPaths = [];
                        // Extract categories from front matter.
                        if (front.categories !== undefined) {
                            // front.categories can be a YAML array or plain string.
                            let cats = front.categories.trim();
                            let arr;
                            if (cats.startsWith('[') && cats.endsWith(']')) {
                                // remove brackets and split by comma
                                cats = cats.slice(1, -1);
                                arr = cats.split(',').map(s => s.trim());
                            } else {
                                arr = [cats];
                            }
                            arr.forEach(cat => {
                                // split nested categories by /
                                const segs = cat.split('/')
                                    .map(s => s.trim())
                                    .filter(Boolean);
                                if (segs.length > 0) {
                                    categoryPaths.push(segs);
                                }
                            });
                        } else if (front.category !== undefined) {
                            // single category
                            const cat = front.category.trim();
                            const segs = cat.split('/')
                                .map(s => s.trim())
                                .filter(Boolean);
                            if (segs.length > 0) {
                                categoryPaths.push(segs);
                            }
                        }
                        // If no categories specified, fall back to folder path (parentPath)
                        if (categoryPaths.length === 0) {
                            categoryPaths.push(parentPath);
                        }
                        const postIndex = posts.length;
                        posts.push({ title, date, html, excerpt, categoryPaths });
                        // Add the post to the category tree for each category path
                        categoryPaths.forEach(cp => {
                            addPostToTree(cp, postIndex);
                        });
                    } catch (err) {
                        console.error('Error loading post', item.name, err);
                    }
                }
            }
        }

        /**
         * Add a post index to the category tree at the given path.
         * @param {string[]} pathSegments 
         * @param {number} postIndex 
         */
        function addPostToTree(pathSegments, postIndex) {
            let node = categoryTree;
            for (const seg of pathSegments) {
                if (!node.children[seg]) {
                    node.children[seg] = { name: seg, path: [...(node.path || []), seg], children: {}, posts: [] };
                }
                node = node.children[seg];
            }
            node.posts.push(postIndex);
        }

        /**
         * Count total posts under a node, including in descendant categories.
         * @param {object} node 
         * @returns {number}
         */
        function countPostsInNode(node) {
            let count = node.posts ? node.posts.length : 0;
            for (const key in node.children) {
                count += countPostsInNode(node.children[key]);
            }
            return count;
        }

        /**
         * Render the category tree into the sidebar.  Each node displays its name and
         * the number of posts under it.  Clicking a node selects it and toggles its open state.
         */
        function renderCategoryTree() {
            const container = document.getElementById('category-tree');
            container.innerHTML = '';
            // Create "All posts" root entry
            const rootLi = document.createElement('div');
            rootLi.className = 'cat-item root';
            const rootLabel = document.createElement('div');
            rootLabel.className = 'cat-label d-flex justify-content-between align-items-center';
            rootLabel.innerHTML = `<span>All posts</span><span class="badge badge-light ml-2">${posts.length}</span>`;
            rootLabel.addEventListener('click', () => {
                currentCategoryPath = [];
                renderBlogFeed();
                updateActiveCategory();
            });
            rootLi.appendChild(rootLabel);
            container.appendChild(rootLi);
            // Recursive helper to build nested categories
            function build(node, parentEl) {
                const ul = document.createElement('ul');
                ul.className = 'cat-sublist';
                for (const name of Object.keys(node.children).sort()) {
                    const child = node.children[name];
                    const li = document.createElement('li');
                    li.className = 'cat-item';
                    li.dataset.path = JSON.stringify(child.path);
                    const label = document.createElement('div');
                    label.className = 'cat-label d-flex justify-content-between align-items-center';
                    label.innerHTML = `<span>${name}</span><span class="badge badge-light ml-2">${countPostsInNode(child)}</span>`;
                    label.addEventListener('click', (e) => {
                        e.stopPropagation();
                        li.classList.toggle('open');
                        currentCategoryPath = child.path;
                        renderBlogFeed();
                        updateActiveCategory();
                    });
                    li.appendChild(label);
                    if (Object.keys(child.children).length > 0) {
                        build(child, li);
                    }
                    ul.appendChild(li);
                }
                parentEl.appendChild(ul);
            }
            build(categoryTree, container);
            updateActiveCategory();
        }

        /**
         * Highlight the currently selected category by adding 'active' class.
         */
        function updateActiveCategory() {
            const items = document.querySelectorAll('#category-tree .cat-item');
            items.forEach(item => {
                item.classList.remove('active');
                const path = JSON.parse(item.dataset.path || '[]');
                if (path.length === currentCategoryPath.length &&
                    path.every((seg, idx) => seg === currentCategoryPath[idx])) {
                    item.classList.add('active');
                    // ensure parent nodes are open
                    let parent = item.parentElement;
                    while (parent && parent.id !== 'category-tree') {
                        if (parent.classList.contains('cat-item')) {
                            parent.classList.add('open');
                        }
                        parent = parent.parentElement;
                    }
                }
            });
        }

        /**
         * Render the blog feed based on current category and search query.
         */
        function renderBlogFeed() {
            const feed = document.getElementById('blog-feed');
            const postView = document.getElementById('blog-post');
            // If post is open, hide feed (it will be shown after back)
            if (postView.style.display !== 'none') {
                return;
            }
            feed.innerHTML = '';
            // Determine which posts to show
            const indices = [];
            posts.forEach((post, idx) => {
                // Category filter: include post if currentCategoryPath empty or any of its category paths matches the selection prefix
                let matchCategory;
                if (currentCategoryPath.length === 0) {
                    matchCategory = true;
                } else if (Array.isArray(post.categoryPaths)) {
                    matchCategory = post.categoryPaths.some(cp => {
                        // cp may be shorter than currentCategoryPath; ensure prefix matches
                        if (!Array.isArray(cp)) return false;
                        return currentCategoryPath.every((seg, i) => cp[i] === seg);
                    });
                } else {
                    matchCategory = false;
                }
                // Search filter
                const lcQuery = searchQuery.toLowerCase();
                const matchSearch = !searchQuery || (
                    (post.title && post.title.toLowerCase().includes(lcQuery)) ||
                    (post.date && post.date.toLowerCase().includes(lcQuery)) ||
                    (post.excerpt && post.excerpt.toLowerCase().includes(lcQuery))
                );
                if (matchCategory && matchSearch) {
                    indices.push(idx);
                }
            });
            // Sort posts by date descending (empty dates go last)
            indices.sort((a, b) => {
                const da = posts[a].date || '';
                const db = posts[b].date || '';
                return db.localeCompare(da);
            });
            // Create cards
            if (indices.length === 0) {
                const noMsg = document.createElement('p');
                noMsg.className = 'text-muted';
                noMsg.textContent = 'No posts found.';
                feed.appendChild(noMsg);
                return;
            }
            indices.forEach(idx => {
                const post = posts[idx];
                const col = document.createElement('div');
                col.className = 'col-12 col-md-6 col-lg-4 mb-4';
                const card = document.createElement('div');
                card.className = 'post-card h-100 d-flex flex-column';
                // header: title
                const header = document.createElement('h5');
                header.className = 'mb-1';
                header.textContent = post.title;
                card.appendChild(header);
                // date
                if (post.date) {
                    const dateEl = document.createElement('div');
                    dateEl.className = 'text-muted small mb-2';
                    dateEl.textContent = post.date;
                    card.appendChild(dateEl);
                }
                // excerpt
                const excerptEl = document.createElement('p');
                excerptEl.className = 'flex-grow-1';
                excerptEl.textContent = post.excerpt + '...';
                card.appendChild(excerptEl);
                // button
                const btn = document.createElement('button');
                btn.className = 'btn btn-sm btn-primary align-self-start mb-2';
                btn.textContent = 'Read more';
                btn.addEventListener('click', () => {
                    showPost(idx);
                });
                card.appendChild(btn);
                col.appendChild(card);
                feed.appendChild(col);
            });
        }

        /**
         * Show a single post.  Hides the feed and displays post content.
         * @param {number} index 
         */
        function showPost(index) {
            const post = posts[index];
            if (!post) return;
            const feed = document.getElementById('blog-feed');
            feed.style.display = 'none';
            const postContainer = document.getElementById('blog-post');
            const postContent = document.getElementById('blog-post-content');
            postContent.innerHTML = `<h3>${post.title}</h3>` + post.html;
            // Typeset math if MathJax available
            if (window.MathJax && typeof window.MathJax.typeset === 'function') {
                try {
                    if (typeof MathJax.typesetPromise === 'function') {
                        MathJax.typesetPromise([postContent]);
                    } else {
                        MathJax.typeset();
                    }
                } catch (e) {
                    console.warn('MathJax typesetting error:', e);
                }
            }
            postContainer.style.display = '';
            // scroll to top
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        // Back to list button
        document.addEventListener('DOMContentLoaded', () => {
            const back = document.getElementById('back-to-list');
            back.addEventListener('click', () => {
                document.getElementById('blog-post').style.display = 'none';
                document.getElementById('blog-feed').style.display = '';
                window.scrollTo({ top: document.getElementById('blog').offsetTop, behavior: 'smooth' });
            });
            // Fetch posts and initialise UI
            fetchPostsFromDir('', []).then(() => {
                renderCategoryTree();
                renderBlogFeed();
            });
            // Search input handler
            document.getElementById('blog-search').addEventListener('input', (e) => {
                searchQuery = e.target.value.trim();
                renderBlogFeed();
            });
        });
    </script>
</body>

</html>